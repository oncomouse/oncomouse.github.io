<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
  <head>
    <!-- 2024-06-14 Fri 15:24 -->
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Backwards into the Future: Writing the Retro-computer</title>
    <meta name="author" content="Andrew Pilsch" />
    <meta name="generator" content="Org Mode" />
    <style>
      html {
        font-size: 20px;
      }
      p {
        line-height: 2;
        margin-bottom: 0;
        margin-top: 0;
        text-indent: 2rem;
      }
      blockquote p,
      blockquote + p {
        text-indent: 0;
      }
      .ta-center {
          text-align: center;
      }
      .csl-entry {
        margin-bottom: 1rem;
      }
      #content {
        max-width: 60em;
        margin: auto;
      }
      .title {
        text-align: center;
        margin-bottom: 0.2em;
      }
      .subtitle {
        text-align: center;
        font-size: medium;
        font-weight: bold;
        margin-top: 0;
      }
      .todo {
        font-family: monospace;
        color: red;
      }
      .done {
        font-family: monospace;
        color: green;
      }
      .priority {
        font-family: monospace;
        color: orange;
      }
      .tag {
        background-color: #eee;
        font-family: monospace;
        padding: 2px;
        font-size: 80%;
        font-weight: normal;
      }
      .timestamp {
        color: #bebebe;
      }
      .timestamp-kwd {
        color: #5f9ea0;
      }
      .org-right {
        margin-left: auto;
        margin-right: 0px;
        text-align: right;
      }
      .org-left {
        margin-left: 0px;
        margin-right: auto;
        text-align: left;
      }
      .org-center {
        margin-left: auto;
        margin-right: auto;
        text-align: center;
      }
      .underline {
        text-decoration: underline;
      }
      #postamble p,
      #preamble p {
        font-size: 90%;
        margin: 0.2em;
      }
      p.verse {
        margin-left: 3%;
      }
      pre {
        border: 1px solid #e6e6e6;
        border-radius: 3px;
        background-color: #f2f2f2;
        padding: 8pt;
        font-family: monospace;
        overflow: auto;
        margin: 1.2em;
      }
      pre.src {
        position: relative;
        overflow: auto;
      }
      pre.src:before {
        display: none;
        position: absolute;
        top: -8px;
        right: 12px;
        padding: 3px;
        color: #555;
        background-color: #f2f2f299;
      }
      pre.src:hover:before {
        display: inline;
        margin-top: 14px;
      }
      /* Languages per Org manual */
      pre.src-asymptote:before {
        content: "Asymptote";
      }
      pre.src-awk:before {
        content: "Awk";
      }
      pre.src-authinfo::before {
        content: "Authinfo";
      }
      pre.src-C:before {
        content: "C";
      }
      /* pre.src-C++ doesn't work in CSS */
      pre.src-clojure:before {
        content: "Clojure";
      }
      pre.src-css:before {
        content: "CSS";
      }
      pre.src-D:before {
        content: "D";
      }
      pre.src-ditaa:before {
        content: "ditaa";
      }
      pre.src-dot:before {
        content: "Graphviz";
      }
      pre.src-calc:before {
        content: "Emacs Calc";
      }
      pre.src-emacs-lisp:before {
        content: "Emacs Lisp";
      }
      pre.src-fortran:before {
        content: "Fortran";
      }
      pre.src-gnuplot:before {
        content: "gnuplot";
      }
      pre.src-haskell:before {
        content: "Haskell";
      }
      pre.src-hledger:before {
        content: "hledger";
      }
      pre.src-java:before {
        content: "Java";
      }
      pre.src-js:before {
        content: "Javascript";
      }
      pre.src-latex:before {
        content: "LaTeX";
      }
      pre.src-ledger:before {
        content: "Ledger";
      }
      pre.src-lisp:before {
        content: "Lisp";
      }
      pre.src-lilypond:before {
        content: "Lilypond";
      }
      pre.src-lua:before {
        content: "Lua";
      }
      pre.src-matlab:before {
        content: "MATLAB";
      }
      pre.src-mscgen:before {
        content: "Mscgen";
      }
      pre.src-ocaml:before {
        content: "Objective Caml";
      }
      pre.src-octave:before {
        content: "Octave";
      }
      pre.src-org:before {
        content: "Org mode";
      }
      pre.src-oz:before {
        content: "OZ";
      }
      pre.src-plantuml:before {
        content: "Plantuml";
      }
      pre.src-processing:before {
        content: "Processing.js";
      }
      pre.src-python:before {
        content: "Python";
      }
      pre.src-R:before {
        content: "R";
      }
      pre.src-ruby:before {
        content: "Ruby";
      }
      pre.src-sass:before {
        content: "Sass";
      }
      pre.src-scheme:before {
        content: "Scheme";
      }
      pre.src-screen:before {
        content: "Gnu Screen";
      }
      pre.src-sed:before {
        content: "Sed";
      }
      pre.src-sh:before {
        content: "shell";
      }
      pre.src-sql:before {
        content: "SQL";
      }
      pre.src-sqlite:before {
        content: "SQLite";
      }
      /* additional languages in org.el's org-babel-load-languages alist */
      pre.src-forth:before {
        content: "Forth";
      }
      pre.src-io:before {
        content: "IO";
      }
      pre.src-J:before {
        content: "J";
      }
      pre.src-makefile:before {
        content: "Makefile";
      }
      pre.src-maxima:before {
        content: "Maxima";
      }
      pre.src-perl:before {
        content: "Perl";
      }
      pre.src-picolisp:before {
        content: "Pico Lisp";
      }
      pre.src-scala:before {
        content: "Scala";
      }
      pre.src-shell:before {
        content: "Shell Script";
      }
      pre.src-ebnf2ps:before {
        content: "ebfn2ps";
      }
      /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
      pre.src-cpp:before {
        content: "C++";
      }
      pre.src-abc:before {
        content: "ABC";
      }
      pre.src-coq:before {
        content: "Coq";
      }
      pre.src-groovy:before {
        content: "Groovy";
      }
      /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
      pre.src-bash:before {
        content: "bash";
      }
      pre.src-csh:before {
        content: "csh";
      }
      pre.src-ash:before {
        content: "ash";
      }
      pre.src-dash:before {
        content: "dash";
      }
      pre.src-ksh:before {
        content: "ksh";
      }
      pre.src-mksh:before {
        content: "mksh";
      }
      pre.src-posh:before {
        content: "posh";
      }
      /* Additional Emacs modes also supported by the LaTeX listings package */
      pre.src-ada:before {
        content: "Ada";
      }
      pre.src-asm:before {
        content: "Assembler";
      }
      pre.src-caml:before {
        content: "Caml";
      }
      pre.src-delphi:before {
        content: "Delphi";
      }
      pre.src-html:before {
        content: "HTML";
      }
      pre.src-idl:before {
        content: "IDL";
      }
      pre.src-mercury:before {
        content: "Mercury";
      }
      pre.src-metapost:before {
        content: "MetaPost";
      }
      pre.src-modula-2:before {
        content: "Modula-2";
      }
      pre.src-pascal:before {
        content: "Pascal";
      }
      pre.src-ps:before {
        content: "PostScript";
      }
      pre.src-prolog:before {
        content: "Prolog";
      }
      pre.src-simula:before {
        content: "Simula";
      }
      pre.src-tcl:before {
        content: "tcl";
      }
      pre.src-tex:before {
        content: "TeX";
      }
      pre.src-plain-tex:before {
        content: "Plain TeX";
      }
      pre.src-verilog:before {
        content: "Verilog";
      }
      pre.src-vhdl:before {
        content: "VHDL";
      }
      pre.src-xml:before {
        content: "XML";
      }
      pre.src-nxml:before {
        content: "XML";
      }
      /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
      pre.src-conf:before {
        content: "Configuration File";
      }

      table {
        border-collapse: collapse;
      }
      caption.t-above {
        caption-side: top;
      }
      caption.t-bottom {
        caption-side: bottom;
      }
      td,
      th {
        vertical-align: top;
      }
      th.org-right {
        text-align: center;
      }
      th.org-left {
        text-align: center;
      }
      th.org-center {
        text-align: center;
      }
      td.org-right {
        text-align: right;
      }
      td.org-left {
        text-align: left;
      }
      td.org-center {
        text-align: center;
      }
      dt {
        font-weight: bold;
      }
      .footpara {
        display: inline;
      }
      .footdef {
        margin-bottom: 1em;
      }
      .figure {
        padding: 1em;
      }
      .figure p {
        text-align: center;
      }
      .equation-container {
        display: table;
        text-align: center;
        width: 100%;
      }
      .equation {
        vertical-align: middle;
      }
      .equation-label {
        display: table-cell;
        text-align: right;
        vertical-align: middle;
      }
      .inlinetask {
        padding: 10px;
        border: 2px solid gray;
        margin: 10px;
        background: #ffffcc;
      }
      #org-div-home-and-up {
        text-align: right;
        font-size: 70%;
        white-space: nowrap;
      }
      textarea {
        overflow-x: auto;
      }
      .linenr {
        font-size: smaller;
      }
      .code-highlighted {
        background-color: #ffff00;
      }
      .org-info-js_info-navigation {
        border-style: none;
      }
      #org-info-js_console-label {
        font-size: 10px;
        font-weight: bold;
        white-space: nowrap;
      }
      .org-info-js_search-highlight {
        background-color: #ffff00;
        color: #000000;
        font-weight: bold;
      }
      .org-svg {
      }
      kbd {
        border-radius: 2px;
        overflow-y: hidden;
        overflow-x: auto;
        padding: 0.4rem 0.4rem 0.2rem;
        background-color: #efeff0;
        font-size: 1.65rem;
        color: #e528b0;
        font-family: "Consolas", "Monaco", "Courier New", monospace;
        line-height: 1;
      }
    </style>
  </head>
  <body>
    <div id="content" class="content">
      <h1 class="title">
        Backwards into the Future: Writing the Retro-computer
      </h1>
      <h2>Computers & Writing 2024, Fort Worth, TX</h2>
      <p>
        Click on the slides and then use <kbd>&#8592;</kbd> and
        <kbd>&#8594;</kbd> to navigate. Alternately,
        <a
          href="//oncomouse.github.io/slides/conferences/dhsi18/presentation.html#1"
          target="_blank"
          >click here to open in a new window</a
        >.
      </p>
      <div class="ta-center">
        <iframe
          style="width: 800px; height: 600px"
          src="//oncomouse.github.io/slides/conferences/cwcon24.html#1"
        ></iframe>
      </div>
      <p>
        In a video for <i>Textshop Experiments</i> entitled "Haptic Heuretics,"
        Jason Crider and Chole Anna Milligan describe a WriteBox&#x2014;a
        Raspberry Pi running Linux and connected to a mechanical
        keyboard&#x2014;that helps them imagine writing technologies outside the
        remediated literate models of word processing applications. They talk
        about their system, deprioritizing graphical user interfaces in favor of
        the command line and requiring tinkering with the code ("getting our
        hands dirty") in order to reinvent writing for an electrate age and
        re-emerge the prospects for experimenting with print that were lost with
        the stabilization and normalization of literate practices.<sup
          ><a id="fnr.1" class="footref" href="#fn.1" role="doc-backlink"
            >1</a
          ></sup
        >
      </p>

      <p>
        Crider and Milligan position their WriteBox as an avant-garde
        experiment, which is weird for me, as I write on my self-built desktop
        computer running (<b><b>slide</b></b
        >) Arch Linux and typing into a 50-year-old text editor called (<b
          ><b>slide</b></b
        >) Vi with a (<b><b>slide</b></b
        >) custom-built mechanical keyboard. I guess what I'm trying to say is
        that it was a bit alienating watching their video for the first time,
        and seeing what has been my academic writing workflow for the last
        decade described as a cutting-edge practice experimenting at the limits
        of the written word.
      </p>

      <p>I thought I was just trying to get tenure.</p>

      <p>
        I bring all this up, today, though because I want to talk about why John
        Tinnell's biography of Mark Weiser,
        <i>The Philosopher of Palo Alto</i> resonates so strongly with me and
        has lead me to seriously consider the possibility that I might actually
        be doing something important vis-a-vis reinventing the possibilities of
        the written word. Moreover, I want to think about the (<b
          ><b>slide</b></b
        >) context of the keyboard-centric programs, both comparatively ancient
        ones such as Vi or Ratpoison (the mouseless window manager that provides
        a minimal GUI (mostly so I can watch YouTube), first released almost 25
        years ago) or the myriad recently-authored, high-powered CLI tools that
        are reinvigorating non-desktop-centric workflows for a variety of users.
        Based on these experiences, I want to tease a thread out of Weiser's
        work (and Tinnell's writing about him) that highlights how Weiser's
        dream of ubicomp shares two goals that are actually quite different. On
        the hand, we have the famous idea to re-world the computer, building
        ubiquitous computational power into a myriad of everyday smart
        environments in which our life opens outside the context of the computer
        desk. But, on the other hand, in a move that I don't think is even
        entirely clear to Weiser himself, ubicomp is positioning itself against
        what Crider and Mulligan label as the black-boxing of the writing
        apparatus of the desktop computing paradigm. Based on Tinnell's
        biography of him and my own reading of Weiser's work, I get the distinct
        impression that Weiser hated desktop computing, and I wonder if the
        destabilizing of writing interfaces my practice represents might offer a
        solution to one of the two problems Weiser was working on. Further, this
        turn to retro-computing as another kind of post-desktop interface
        highlights the strong connection between Weiser's model of
        ubicomp&#x2014;tabs, pads, and boards&#x2014;and the UNIX philosophy of
        small, well-built digital tools working together in harmony.
      </p>

      <p>
        In this context, I also want to think about tools as Mark Weiser
        understood them and what this means for the two images of post-desktop
        computing he gives us: the version of ubiquitous computing we could have
        had and the version that he says repeatedly in his writing is terrible
        that we got and have found, largely, to be terrible. As we know from
        reading Tinnell's biography, <i>The Philosopher of Palo Alto</i>, and
        from reading Weiser's work, there are two famous models for the
        computing tools Weiser hoped to build at Xerox PARC: the candy bar
        wrapper, whose literate information practices are at-hand until we
        consult them, never commanding our attention; and the blind person's
        cane, which, as Tinnell draws out, Weiser sourced from reading Michael
        Polyani's work. The cane to Weiser is not felt by its users, instead,
        vibrations transmitted up the shaft allow the wielder to feel the road.
        In the case of the candy bar wrapper, its information is there when we
        want it but does not solicit our attention when we do not; in the case
        of the cane, the cane is not the focus, the experience of the world thus
        facilitated is. In both cases, the tool itself vanishes.
      </p>

      <p>
        In "The World is Not a Desktop" (1993), Weiser once again uses the cane
        to introduce the invisible computers he hopes to build. He then
        contrasts this with a variety of vaporware&#x2014;virtual reality, voice
        activation, intelligent agents&#x2014;which now form the clanging,
        screeching, flashing attention-suck of contemporary mobile computing. In
        between these two poles, however, he briefly mentions vi, and this
        mention is where my own project begins.
      </p>

      <p>
        Here's what he says, and I think it's important to dwell on this for a
        second (<b><b>slide</b></b
        >):
      </p>

      <blockquote>
        <p>
          Of course, tools are not invisible in themselves, but as part of a
          context of use. With enough practice we can make many apparently
          difficult things disappear: my fingers know vi editing commands that
          my conscious mind has long forgotten. But good tools enhance
          invisibility.<sup
            ><a id="fnr.2" class="footref" href="#fn.2" role="doc-backlink"
              >2</a
            ></sup
          >
        </p>
      </blockquote>

      <p>
        I'm assuming most of you don't know what vi is, so I'll explain it:
        there are two classic text editors developed in the 1970s that are still
        in fairly wide use today, vi and emacs. Both predate both the IBM Common
        User Access (1987), which defined many of the editing operations we know
        and love, such as "cut" or "save," (which is why "yank" in vi performs
        what we would call "copy" in MS Word while "yank" in emacs performs what
        we would call "paste") and both have very particular ways of interacting
        with text. Vi in particular is what is known as a "modal editor" (and
        until a few years ago was basically the only text editor operating in
        this paradigm). (<b><b>slide</b></b
        >) In modal editing, operating on the text (deleting, yanking,
        navigating) is one mode in which the user can interact, inserting text
        is a second mode (there is also visual mode, which controls
        highlighting). The editor predates the general adoption of mice (and,
        importantly, predates the desktop paradigm), so everything is done via
        the keyboard, hence the reason for the different modes. In vi, in normal
        and visual modes, the characters <code>h</code>, <code>j</code>,
        <code>k</code>, and <code>l</code> control the cursor's position (left,
        down, up, and right), while in insert mode, they simply type the letters
        represented. Vi also has the concept of a textobject, things like words,
        sentences, and paragraphs, which are worked on in normal mode via
        operators. This is both part of vi's challenge to new users and its
        power for those who make use of it: you can do <b>everything</b> without
        having to take your hands off the keyboard: no menus, no mice, just
        typing. For instance, if I wanted to change the word my cursor was on in
        normal mode, I would type <code>ciw</code> (*c*hange, *i*nner, *w*ord),
        be placed into insert mode, type the new word, and hit
        <code>ESC</code> to return to normal mode. Things start getting really
        powerful when you discover that all operations can be multiplied by
        pressing a number before them, so <code>3yas</code> will yank the next
        three sentences to the clipboard.
      </p>

      <p>
        This all sounds very confusing, I would imagine, and vi has a
        notoriously steep learning curve. There's a bit of computer science lore
        that imagines both these editors as exotic, far-off islands that some
        programmers hear rumors of while a few programmers will dare to visit
        and even fewer still will choose to settle and stay. Despite this, (<b
          ><b>slide</b></b
        >) in the 2023 Stack Overflow Developer Survey of around 86,000 users,
        Vim (one of the two modern versions of vi in widespread use) ranked
        fifth amongst text editors with 22% daily usage (ahead of Jupyter
        Notebooks and Sublime Text), while Neovim (the newer, better fork of
        Vim) ranked tenth with 11.8% daily usage. Vi users tend to be particular
        (I have vi bindings installed on any program that will let me use them)
        and loyal, but the reason for this, as Weiser points out is that if vi
        grabs you, you'll learn to use it as second nature, to the point that vi
        just becomes how you think about interacting with text at a bodily
        level. What I mean by this is that, when colleagues force me to use
        Google Docs to collaboratively edit Word documents, they constantly find
        vi motions inserted into the text, because I'm so used to inputting text
        into vi that I've forgotten I can't type <code>cis</code> to change that
        badly-wrought sentence into a more perfectly formed unit. I once
        explained to a colleague, echoing Weiser before I'd read him, that vi
        has taught me that "writing comes from my hands."
      </p>

      <p>
        Which brings me, I hope, back to Weiser's invocation in 1994: note the
        ambiguous "but" that transitions between "My fingers know vi" and "good
        tools enhance invisibility." What are we take from this? "But" might
        imply that vi is not a good tool, or that its invisibility is despite of
        its difficulty. It's important for me to know which it is. I think vi is
        a very good tool, but I use it everyday and, as Weiser and my anecdote
        both illustrate, it has changed my bodily operation such that writing in
        vi is more natural than writing in any other tool, including paper and
        pen. However, someone first starting out with vi may not agree with me.
      </p>

      <p>
        My experience of vi, as I type these words for instance, is one in
        which, like Polyani's cane-using blind person, I don't feel the
        computer, I feel the words. So, in one way, vi becomes invisible in the
        Weiserian sense. However, as Weiser outlines in "The World is Not a
        Desktop" but explored more fully in "A Computer for the 21st Century,"
        the goal of Weiser's model of ubiquitous computing is to reengage the
        user with the world around them, instead of drawing them further into
        the computer. He negatively surveys five emerging models for
        post-desktop computing&#x2014;multimedia, intelligent agents, magic,
        virtual reality, and voice input&#x2014;showing how each is a form of
        technology both "prominent and attention-grabbing" while reminding us
        that "a good tool is not".<sup
          ><a id="fnr.3" class="footref" href="#fn.3" role="doc-backlink"
            >3</a
          ></sup
        >
      </p>

      <p>
        Moreover, vi is also very engaging: when I write in vi, I feel my hands
        and little else. Without the distraction of visual options such as
        formatting or having to move my hand off the home, writing narrows to
        whatever my thoughts are and the hands that fashion those into words.
        This is opposed, I think diametrically so, to Weiser's stated desire to
        "design a radically new kind of computer that could more deeply
        participate in the world of people".<sup
          ><a id="fnr.4" class="footref" href="#fn.4" role="doc-backlink"
            >4</a
          ></sup
        >
        But, at the same time and by Weiser's own hesitant admission: vi is a
        good tool. I like to think that vi traps me in the world of my writing
        rather than the world of the computer and that marks a crucial
        distinction.
      </p>

      <p>
        Either way, emerging trends, especially in programming, would confirm my
        experiences using vi. As I've mentioned, both version of Vim are in the
        top 10 most popular editors survey, but more pervasively, there has been
        a recent renaissance in command-line tools across the board. Programs
        such as `fd` and `ripgrep` (which leverage modern programming languages
        such as Rust to greatly speed-up finding files), `fzf` (which uses
        fuzzy-find to quickly search and complete menus), and a variety of
        command-line clients for social-media, chat, and music all
        proliferating. Even mobile editors, long confined solely to vi and
        derided as unnecessarily complicated, are being reinvigorated with
        editors such as Kakoune and Helix developing new version of the modal
        paradigm.
      </p>

      <p>
        Petr Stribny, author of
        <i>The Command Line: A Modern Introduction</i>, suggests four reasons
        for both the pervasiveness of command-line software and the modern
        rebirth of many tools:
      </p>

      <blockquote>
        <ol class="org-ol">
          <li>
            We can control systems that don’t have any graphical environment
            installed, including
          </li>
        </ol>
        <p>remote servers, virtual machines, and containers like Docker.</p>
        <ol class="org-ol">
          <li>
            Programs executed on the command line can be combined so that the
            output of one program can be the input of another.
          </li>
          <li>
            Task automation is built-in thanks to the scripting nature of many
            shells. No more doing repetitive tasks manually.
          </li>
          <li>
            There is a low barrier to creating our own CLI applications. Many
            utilities for programmers exist only as command-line programs<sup
              ><a id="fnr.5" class="footref" href="#fn.5" role="doc-backlink"
                >5</a
              ></sup
            >
          </li>
        </ol>
      </blockquote>

      <p>
        Without getting too bogged down in the minutiae of UNIX (from which
        Linux and macOS are both derived), the second of Stribny's four points
        is most particularly relevant here and builds off what's called the Unix
        Philosophy. As documented by Peter H. Salus in
        <i>A Quarter-Century of UNIX</i> (1994), there are three principles that
        governed the original development of UNIX:
      </p>

      <blockquote>
        <ol class="org-ol">
          <li>Write programs that do one thing and do it well.</li>
          <li>Write programs to work together.</li>
          <li>
            Write programs to handle text streams, because that is a universal
            interface.<sup
              ><a id="fnr.6" class="footref" href="#fn.6" role="doc-backlink"
                >6</a
              ></sup
            >
          </li>
        </ol>
      </blockquote>

      <p>
        Essentially, UNIX is composed of a number of small, full-featured
        programs that all interface with one-another to emerge more complicated
        functionality. Take <code>fzf</code>, a program I mentioned earlier
        which takes a list of strings and converts them into a searchable menu.
        On my system, I use fzf to find and quickly open files within a
        directory, sending the results of <code>fd</code> (which quickly lists
        files in a particular directory); but I can also send a list of songs in
        my current playlist in <code>mpd</code> (the Music Player Daemon) to
        select a new track to listen to. Fzf is a program for displaying menus,
        fd is a program for listing files, mpd is a program for playing music,
        but they allow for almost infinite workflow personalization.
      </p>

      <p>
        For careful readers of Weiser's work, this UNIX philosophy might sound,
        as it does to me, like his proposal for ubiquitous computing built
        around three scales, originally as Tinnell shows "tiny," "medium," and
        "large" later, more famously, "tabs, pads, and boards".<sup
          ><a id="fnr.7" class="footref" href="#fn.7" role="doc-backlink"
            >7</a
          ></sup
        >
        Tabs, "the smallest yet most sophisticated of the three ubicomp building
        blocks" were tiny computers that interacted with one another as their
        users moved through an office space, displaying relevant information and
        constructing "a shape-shifting constellation, each day's end revealing a
        fresh portrait of the lab's people and things".<sup
          ><a id="fnr.8" class="footref" href="#fn.8" role="doc-backlink"
            >8</a
          ></sup
        >
      </p>

      <p>
        Tabs, then, form the location-aware, networked building blocks of
        Weiser's ubicomp vision, but they also clearly harken back to the Unix
        philosophy of doing one thing really well and connecting to other
        programs for other parts of a particular operation. The UNIX philosophy
        defined an ecosystem of tools strangely akin to the post-desktop
        ecosystem Weiser imagined. The difference is that UNIX is still
        box-bound, a la desktop computing, while Weiser's stated aim (and the
        aspect of his work he most focused on) is building computing that
        facilitates its users engagement with their surroundings.
      </p>

      <p>
        The lynchpin here&#x2014;and one of the problems Weiser had to address
        due to his historical moment and his position as director of Xerox
        PARC&#x2014;is the desktop computer. Writing about the transition from
        CLI to GUI in <i>Actionable Media</i>, Tinnell notes that the GUI
        "effectively broke down […] the command line interface into a new set of
        images, prescribed options, and standard protocols. Users could identify
        an option […] and simply click on it".<sup
          ><a id="fnr.9" class="footref" href="#fn.9" role="doc-backlink"
            >9</a
          ></sup
        >
        In analyzing the iPad as a failed model of Weiser's original ubicomp
        Pad, Lori Emerson highlights that slick GUI interfaces (and their mobile
        inheritors) work like stage magic in which "[the audience] must remain
        in the dark (literally and figuratively) about exactly how the trick
        works".<sup
          ><a id="fnr.10" class="footref" href="#fn.10" role="doc-backlink"
            >10</a
          ></sup
        >
        Following Weiser's thinking, Tinnell argues that attention-hungry
        interfaces that demand a user "withdraw from a course of local action in
        favor of tele-action".<sup
          ><a id="fnr.11" class="footref" href="#fn.11" role="doc-backlink"
            >11</a
          ></sup
        >
        Tracing the hype-centric news coverage of the iPad's launch in the
        context of Weiser's original ubicomp vision, Emerson suggests this
        withdrawal occurs because the iPad, does it all withou the user having
        to think.<sup
          ><a id="fnr.12" class="footref" href="#fn.12" role="doc-backlink"
            >12</a
          ></sup
        >
      </p>

      <p>
        Desktops, and their mobile progeny, capture the full attention of their
        users and, more importantly, attempt to be the single source of all
        computable action in their lives (in contrast to Weiser's 100s of
        computers or his command to "spread many electronic pads around on the
        desk, just as you spread out papers" in "Computer for the 21st
        Century").<sup
          ><a id="fnr.13" class="footref" href="#fn.13" role="doc-backlink"
            >13</a
          ></sup
        >
        More importantly, though (and this is something you can find documented
        in Ellen Ullman's writing about the early web in
        <i>Close to the Machine</i> and in Steven Levy's classic "A Spreadsheet
        Way of Knowledge"), the desktop reduces all the complex richness
        afforded by shortcut-oriented, keyboard-centric apps in general (with
        their "[cumbersome] bits of arbitrary command language" as Tinnell calls
        them) into a mouse pointer and a bunch of opaque menus.
      </p>

      <p>
        None of this richness gets me the world, though. But I think that's
        okay. My version of the Crider-Mulligan WriteBox is built for writing: I
        autocomplete citations into my Markdown manuscripts using Neovim's
        completion system, those citation codes are generated by Zotero and
        compiled into a works cited by Pandoc's citeproc package, I can import
        citations from Firefox automatically. My system, however, has trouble
        playing video games because ratpoison's support for fullscreen
        applications is dodgy, I'd rather send texts on my phone anyway, and
        does Netflix like Linux? It does not. And yet, as Nietzsche says, "it
        resembles me."
      </p>

      <p>
        This leads me to my conclusion: the personal computer was a mistake and
        Mark Weiser, I think, figured it out first. As a professional wordsmith,
        I need something like my WriteBox (akin to George R.R. Martin's famous
        use of the outdated (and keyboard-centric) Wordstar to compose his Song
        of Ice and Fire novels) because crushing text as quickly and efficiently
        as possible is my job. Do my students need this? Probably not. Did
        random people buying Windows 95 on launch day need this? No, almost
        certainly not.
      </p>

      <p>
        Weiser was imagining post-desktop computing for casual literacy
        practices on the go, not for the kind of intense writing I've been doing
        for the last few hours working on this talk. And that's fine. I think
        it's worth dwelling on, though, that desktop computing doesn't work for
        me either, and given the increasing general popularity of mechanical
        keyboards, the widespread adoption of tiling window managers such as
        Hyprland or i3 by hipster developers who would have worked on macOS a
        decade ago, and the perennial popularity of Vim, a growing segment of
        information workers recognize that desktop computing doesn't work for
        them, as well. I wonder, perhaps cheekily perhaps not, if desktop
        computing ever actually worked for anyone except PC makers and
        Microsoft.
      </p>

      <p>
        These are all, however, unexpected developments in personal computing
        that Weiser didn't live to see. At the time of his death in 1999, Linux
        was only 9 years old and had only had its first desktop environment
        (KDE) for less than a year. While NextStep had been acquired by Apple,
        Mac OS X (also based on UNIX) was still two years away from release.
        While we could debate the merits of Apple's UNIX-usage, especially in
        light of recent decisions by the company, the point is that the
        possibility of UNIX as a personal OS (and therefore the ability to
        produce something like a WriteBox for oneself) was not as
        straightforwardly apparent during Weiser's life as it is now.
      </p>

      <p>
        While the struggle to imagine a more human-centric ubicomp future is
        still paramount especially given the increasing entanglement between the
        MIT Media Lab's concept of the intelligent agent (which largely won out
        as the dominant paradigm for ubicomp over Weiser's vision) and mass
        surveillance, we should also remain cognizant of the perniciousness of
        the desktop paradigm and the possibilities inherent in the forms of
        retro-computing I've been discussing to free our more intensely literate
        computing practices from the confines of the desktop paradigm.
      </p>

      <p>Thank You</p>

        <h2 class="footnotes">References:</h2>
      <style>
        .csl-entry {
          text-indent: -1.5em;
          margin-left: 1.5em;
        }
      </style>
      <div class="csl-bib-body">
        <div class="csl-entry">
          Crider, Jason, and Chloe Anna Mulligan. “Haptic Heuretics: Electrate
          Tinkering as Rhetorical Making.”
          <i>Textshop Experiments</i> 4 (2018).
        </div>
        <div class="csl-entry">
          Emerson, Lori.
          <i>Reading Writing Interfaces: From the Digital to the Bookbound</i>.
          Minneapolis: Univ Of Minnesota Press, 2014.
        </div>
        <div class="csl-entry">
          Salus, Peter. <i>A Quarter Century Of UNIX</i>. Addison-Wesley, 1994.
        </div>
        <div class="csl-entry">
          Stribny, Petr. <i>Command Line: A Modern Introduction</i>. Gumroad,
          2018.
        </div>
        <div class="csl-entry">
          Tinnell, John.
          <i>Actionable Media: Digital Communication Beyond the Desktop</i>. 1st
          edition. Oxford University Press, 2017.
        </div>
        <div class="csl-entry">
          ———.
          <i
            >The Philosopher of Palo Alto: Mark Weiser, Xerox PARC, and the
            Original Internet of Things</i
          >. University of Chicago Press, 2023.
        </div>
        <div class="csl-entry">
          Weiser, Mark. “The Computer for the 21st Century.”
          <i>Scientific American</i>, September 1991.
        </div>
        <div class="csl-entry">
          ———. “The World Is Not a Desktop.” <i>Interactions</i> 1, no. 1
          (January 1994): 7–8.
          <a href="https://doi.org/10.1145/174800.174801"
            >https://doi.org/10.1145/174800.174801</a
          >.
        </div>
      </div>
      <div id="footnotes">
        <h2 class="footnotes">Footnotes:</h2>
        <div id="text-footnotes">
          <div class="footdef">
            <sup
              ><a id="fn.1" class="footnum" href="#fnr.1" role="doc-backlink"
                >1</a
              ></sup
            >
            <div class="footpara" role="doc-footnote">
              <p class="footpara">
                <a id="citeproc_bib_item_1"></a>Crider and Mulligan, “Haptic
                Heuretics.”
              </p>
            </div>
          </div>

          <div class="footdef">
            <sup
              ><a id="fn.2" class="footnum" href="#fnr.2" role="doc-backlink"
                >2</a
              ></sup
            >
            <div class="footpara" role="doc-footnote">
              <p class="footpara">
                <a id="citeproc_bib_item_8"></a>Weiser, “The World Is Not a
                Desktop.”
              </p>
            </div>
          </div>

          <div class="footdef">
            <sup
              ><a id="fn.3" class="footnum" href="#fnr.3" role="doc-backlink"
                >3</a
              ></sup
            >
            <div class="footpara" role="doc-footnote">
              <p class="footpara">
                <a href="#citeproc_bib_item_8">ibid.</a> n.p.
              </p>
            </div>
          </div>

          <div class="footdef">
            <sup
              ><a id="fn.4" class="footnum" href="#fnr.4" role="doc-backlink"
                >4</a
              ></sup
            >
            <div class="footpara" role="doc-footnote">
              <p class="footpara">
                qtd in <a id="citeproc_bib_item_6"></a>Tinnell,
                <i>The Philosopher of Palo Alto</i>, 119.
              </p>
            </div>
          </div>

          <div class="footdef">
            <sup
              ><a id="fn.5" class="footnum" href="#fnr.5" role="doc-backlink"
                >5</a
              ></sup
            >
            <div class="footpara" role="doc-footnote">
              <p class="footpara">
                <a id="citeproc_bib_item_4"></a>Stribny, <i>Command Line</i>, 2.
              </p>
            </div>
          </div>

          <div class="footdef">
            <sup
              ><a id="fn.6" class="footnum" href="#fnr.6" role="doc-backlink"
                >6</a
              ></sup
            >
            <div class="footpara" role="doc-footnote">
              <p class="footpara">
                <a id="citeproc_bib_item_3"></a>Salus,
                <i>A Quarter Century Of UNIX</i>, 53.
              </p>
            </div>
          </div>

          <div class="footdef">
            <sup
              ><a id="fn.7" class="footnum" href="#fnr.7" role="doc-backlink"
                >7</a
              ></sup
            >
            <div class="footpara" role="doc-footnote">
              <p class="footpara">
                qtd in
                <a href="#citeproc_bib_item_6"
                  >Tinnell, <i>The Philosopher of Palo Alto</i>, 123</a
                >.
              </p>
            </div>
          </div>

          <div class="footdef">
            <sup
              ><a id="fn.8" class="footnum" href="#fnr.8" role="doc-backlink"
                >8</a
              ></sup
            >
            <div class="footpara" role="doc-footnote">
              <p class="footpara">
                <a href="#citeproc_bib_item_6">ibid., 128</a>.
              </p>
            </div>
          </div>

          <div class="footdef">
            <sup
              ><a id="fn.9" class="footnum" href="#fnr.9" role="doc-backlink"
                >9</a
              ></sup
            >
            <div class="footpara" role="doc-footnote">
              <p class="footpara">
                <a id="citeproc_bib_item_5"></a>Tinnell,
                <i>Actionable Media</i>, 96.
              </p>
            </div>
          </div>

          <div class="footdef">
            <sup
              ><a id="fn.10" class="footnum" href="#fnr.10" role="doc-backlink"
                >10</a
              ></sup
            >
            <div class="footpara" role="doc-footnote">
              <p class="footpara">
                <a id="citeproc_bib_item_2"></a>Emerson,
                <i>Reading Writing Interfaces</i>, 14.
              </p>
            </div>
          </div>

          <div class="footdef">
            <sup
              ><a id="fn.11" class="footnum" href="#fnr.11" role="doc-backlink"
                >11</a
              ></sup
            >
            <div class="footpara" role="doc-footnote">
              <p class="footpara">
                <a href="#citeproc_bib_item_5"
                  >Tinnell, <i>Actionable Media</i>, 140</a
                >.
              </p>
            </div>
          </div>

          <div class="footdef">
            <sup
              ><a id="fn.12" class="footnum" href="#fnr.12" role="doc-backlink"
                >12</a
              ></sup
            >
            <div class="footpara" role="doc-footnote">
              <p class="footpara">
                <a href="#citeproc_bib_item_2"
                  >Emerson, <i>Reading Writing Interfaces</i>, 13–19</a
                >.
              </p>
            </div>
          </div>

          <div class="footdef">
            <sup
              ><a id="fn.13" class="footnum" href="#fnr.13" role="doc-backlink"
                >13</a
              ></sup
            >
            <div class="footpara" role="doc-footnote">
              <p class="footpara">
                <a id="citeproc_bib_item_7"></a>Weiser, “The Computer for the
                21st Century,” 99.
              </p>
            </div>
          </div>
        </div>
      </div>
    </div>
    <div id="postamble" class="status">
      <p class="author">Author: Andrew Pilsch</p>
      <p class="date">Created: 2024-06-14 Fri 15:24</p>
    </div>
  </body>
</html>

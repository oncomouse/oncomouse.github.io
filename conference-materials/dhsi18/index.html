<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-type" content="text/html; charset=utf-8"/>
        <link rel="stylesheet" type="text/css" href="../css/project.css"/>
		<title>Conference Materials – DHSI 18</title>
	</head>
	<body>
        <div class="wrapper">
            <h1 class="ta-center">Andrew Pilsch Conference Materials</h1>
            <h2>DHSI 18 Materials</h2>
            <h3>Composition Not Inheritance</h3>
            <h4>Slides</h4>
            <p>
                Click on the slides and then use <kbd>&#8592;</kbd> and <kbd>&#8594;</kbd> to navigate.
                Alternately, <a href="http://oncomouse.github.io/slides/conferences/dhsi18/presentation.html#1" target="_blank">click here to open in a new window</a>.
            </p>
            <div class="ta-center">
                <iframe style="width: 800px; height: 600px;" src="http://oncomouse.github.io/slides/conferences/dhsi18/presentation.html#1"></iframe>
            </div>
            <h4>Transcript</h4>
            <p>
                <a href="dhsi2018.pdf">Click here for a large-print transcript of my talk.</a>
            </p>
            <article>
                <header>
                <h1 class="title">Composition not Inheritance: Imagining a Functional Digital Humanities</h1>
                <p class="author">Andrew Pilsch</p>
                </header>
                <p>Today, I want to talk about software architecture in some detail and how such a fine-grained consideration of industrial programming practices can suggest new, interesting, and I would add important directions for thinking about how we do our business in the digital humanities. As background, I am interested in this question because my current book project—a media archeology of the software bug—is seeking to raise awareness of and to question how much programming work in DH reproduces, intentionally or not, the power structures that are encoded by the programming practices we adopt from industry.</p>
                <p><strong>Slide</strong> This move is inspired by Mark Sample’s intervention into the debate about DH and coding, where he claims that DH is meant to help spread the pleasures and perils of digital culture more evenly through the fields of humanisitic inquiry. However, Sample’s model of DH necessitates thinking specifically about the practices of software-making we borrow from industry and the cultures of power we reproduce as a result.</p>
                <p><strong>Slide</strong> To ground this idea, I want to look at the famous distinction in computer science between composition and inheritance as models for software architecture and DH practice. Composition and inheritance are examples of what are called “design patterns” in software engineering, especially those branches of the field associated with object-oriented programming (OOP). Design patterns are repeatable organizations for OOP projects whose function are considered best practices (design patterns are also juxtaposed in the literature with dreaded “anti-patterns,” or models of design that introduce inefficiency or ill functioning). In software engineering, composition is always to be preferred over inheritance (even though inheritance is often more widely taught in introductory computer science classes because it is more easily understood and more easily implemented). In this presentation, I will first define what both inheritance and composition are, before suggesting that much of DH work is focused on the former instead of the latter, and conclude by suggesting how and why we might better make composite design a part of our thinking about software for humanistic inquiry.</p>
                <h1 id="inheritance">Inheritance</h1>
                <p><strong>Slide</strong> Inheritance is a model implied by the nature of object-oriented software. In most OO languages, the type of a data object is defined by its membership in a class. Classes are categories of data, things like novels or animals or cars. Each specific data instance is instantiated from its class and inherits the class’s interface (so, while books have a number of a pages, a particular book might have 245 pages; while animals might make a noise, a particular animal makes a honking sound).</p>
                <p>Classes in OOP can also inherit characteristics from more abstract classes. That’s what’s going on in this chart here: Barnyard Animals offers a <code>makeNoise()</code> function while Barnyard Bird offers <code>flapWings()</code> and <code>layEggs()</code>. The specific classes of animals (Duck, Chicken, and Donkey) all override their inherited <code>makeNoise</code> function to produce their specific sound.</p>
                <p>This pattern is inheritance. It’s tied to the legacy of Aristotelean, hierarchical thinking in which everything can be classified and ordered; a model of the Universe in which everything makes sense and has a place.</p>
                <p>Despite confirming our mental models of the universe, inheritance is extremely brittle. Adding or changing methods anywhere in the chain can produce all kinds of problems for other instances or less abstract classes. Moreover, what would happen if we suddenly didn’t want to differentiate between birds and mammals, but instead wanted to inherit based on number of legs (two vs four)? Well, that whole diagram goes out the window!</p>
                <h1 id="composition">Composition</h1>
                <p><strong>Slide</strong> Which brings us to composition. In composition, what something is is less important than what it does.</p>
                <p>If the diagram on this slide looks confusing, you’re starting to get why composition is often ignored or deemphasized in teaching computer science. But let’s try to untangle this.</p>
                <p>Where the inheritance diagram was visually clear, it mapped a rigid hierarchy in which categories of things (“Barnyard Animals”) were broken into more specific things (“Barnyard Birds” and “Barnyard Mammals”) before being broken into the things themselves. In this diagram, we have two categories of objects: things and behaviors. The “Noise Making” behavior gives objects that possess it access to noise making (and each animal defines that behavior for itself), while Chickens and Ducks both get “Egg Laying” and “Wing Flapping.” If a natural scientist wanted to come along after the fact and declare wing flapping and egg laying to be characteristics of “birds,” so be it. We don’t care; because we are thinking compositionally, we are only interested in defining behaviors and adding them to the various aspects of our program.</p>
                <p>Composition, besides being the preferred and most widely recommended approach to problem solving in a number of computational domains, focuses on behavior instead of categorization and, therefore, focuses on building or reusing smart, powerful and, most importantly, focused tools for a particular job.</p>
                <h1 id="composing-dh">Composing DH</h1>
                <p>So why this discussion of computer science approaches to design? Thinking through this distinction transforms a key debate in DH on tool usage. In <em>Design Patterns</em>—the 1994 work that inaugurated the topic—, <strong>Slide</strong>inheritance is described as “white-box reuse” while <strong>Slide</strong> composition is described as “black-box reuse” <span class="citation" data-cites="gamma_design_1994">(Gamma et al. 19)</span>. Remember that, here, composition, black-boxing, is strongly recommended. Such a recommendation is perhaps puzzling, given the tradition of denouncing black boxes in DH. <strong>Slide</strong> Joanna Drucker, for instance, has written of the “epistemological biases” of data visualization tools, in which charts and bar graphs claim to stand for reality but instead present intensely mediated visions of the real <span class="citation" data-cites="drucker_humanities_2011">(Drucker 1)</span>. Inheriting a legacy from STS scholarship, part of DH practice has been invested in critiquing and opening black boxes.</p>
                <p>So it would seem weird, at least it seemed weird to me, that this famous CS book is praising black boxes, which are, I think, such a dirty word in DH work. However, the authors of <em>Design Patterns</em> use “black box” a bit differently than we usually use it: in the white-box reuse of inheritance, “the internals of parent classes are often visible to subclasses”; while in the black-box reuse of composition, “no internal details of objects are visible.” Normally, not knowing how something works is seen as a bad thing in DH, so what gives?</p>
                <p><em>Design Patterns</em> uses “black box” to refer to how other objects in the software architecture relate, rather than the author of the code to the code, and this is an important distinction. In a white-box reuse situation, a piece of code explicitly depends on the interface it inherits from more abstract code. A black box reuse situation, however, produces a piece of software that does not depend on any other to be used. This means code is more easily reusable between projects.</p>
                <p>Think, for instance, of why the selection of a content-management system is often so important for a public humanities project. Omeka gets you Neatline, but Drupal gets better user management (though it’s kind of a nightmare to install). Wordpress is easy but not all that useful for doing much. Moreover, any plugins you use or write for any of those CMSs, are going to be lost if you have to switch. While this example probably isn’t inheritance in the strictest sense as it’s used in <em>Design Patterns</em>, the lesson is still worth thinking through: when you choose a tool ecosystem, you are committed to it’s particular interface, you’re bound to what you inherit.</p>
                <p>Moreover, a lot of DH practice is shaped by the kind of hierarchical thinking that drives inheritance. Library catalogs and genre theory are both moments in analog humanities that are driven by inheritance and the structure it provides. Similarly, a project like TEI strongly inscribes a tight, white-boxed data structure and demands users to think strongly about categorization in the way we were discussing earlier (is this a metaphor or a figure? what really <em>is</em> a poem?). We found a software architecture that ostensibly supported what we think we do, and we reproduced that model in digital space. However, is hierarchical thinking all we do in the humanities?</p>
                <p>To answer my own question, I’m going to potential violate some DHSI decorum and talk about [<strong>slide</strong>] Jacques Derrida, specifically the idea of iterability he develops in “Signature, Event, Context.” In that essay, Derrida challenges the idea of writing as conferring presence (specifically the presence of the author) by contrasting presence with difference (or <em>differance</em>, which both differs and defers differing). In this challenge, he constructs reading as iteration and writing as iterable. Each time we read, we read a different text, but each time we read, part of the text escapes and connects to the text as a whole, an aggregate effect.</p>
                <p>In this play of differance Derrida highlights something important to how I think about a functional DH. <strong>Slide</strong> Richard Lanham, in “The Electronic Word,” imagines a utopia of digitization that also foregrounds play as a textual act. Once texts are inside the computer, they become subject to iterations Derrida could not have imagined: remixed, mashed up, turned into bots, made into pictures, translated into gibberish by repeated trips through Google Translate.</p>
                <p>When we get to thinking in terms of inheritance, we forget the personal nature of reading: our own individual iterations versus the stable sense of presence, context, and self-identity that Derrida is critiquing. Digital data, as Lanham reminds us, can be played with, in powerful ways. It can be taken apart and included with other functional components to make new and novel composites. I have been teaching students to play with our digitized literary archive in this fashion: to use texts and images and bits of software to produce new cultural forms and new ideas of criticality. Several students have made interactive fictions based on viral YouTube videos, while others generate fake country lyrics in proper ballad meter. I think this kind of experimental iteration, taking extant tools and literary archives as the raw material for new cultural forms, is an unexplored horizon for DH work, but it calls for a change in the way we think about what our software does, namely moving from inheritance to composition.</p>
                <p>By taking small, well-functioning pieces that all work together with minimal coupling, the work of iteration with digital texts can continue beyond mere digitization. As more archives move online, we need to be thinking more about functionalizing these tools through APIs, open data, and interconnection. This kind of functionalization involves a fundamental acknowledgement that we may not even imagine how people might use our data, but we still need to think about how best to open that data, with a minimal of interface entanglements, so that we can better functionalize our projects and imagine a composite digital humanities.</p>
                <div id="refs" class="references">
                <div id="ref-drucker_humanities_2011">
                <p>Drucker, Johanna. “Humanities Approaches to Graphical Display.” <em>Digital Humanities Quarterly</em>, vol. 005, no. 1, Mar. 2011.</p>
                </div>
                <div id="ref-gamma_design_1994">
                <p>Gamma, Erich, et al. <em>Design Patterns: Elements of Reusable Object-Oriented Software</em>. 1 edition, Addison-Wesley, 1994.</p>
                </div>
                </div>
            </article>
        </div>
	</body>
</html>